<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="linux-kernel 页面分配,">










<meta name="description" content="0x00 前言之前分析一个Linux内核的洞，需要对内存分配这块比较熟悉，这篇文章之前的学习笔记整理。以下所有的源码分析基于linux-4.20-rc3。这篇文件断断续续写了快一个月，这里面东西还有好多，等之后再找时间补上。 0x01 UMA和NUMA模型1.1 UMA模型一致存储器访问（Uniform-Memory-Access，简称UMA）模型，一致性意指无论在什么时候，处理器只能为内存的每个">
<meta name="keywords" content="linux-kernel 页面分配">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内核物理页面内存分配">
<meta property="og:url" content="https://v1ckydxp.github.io/archives/2019/11/09/2019-10-04-Linux内核页面分配/index.html">
<meta property="og:site_name" content="v1cky&#39;blog">
<meta property="og:description" content="0x00 前言之前分析一个Linux内核的洞，需要对内存分配这块比较熟悉，这篇文章之前的学习笔记整理。以下所有的源码分析基于linux-4.20-rc3。这篇文件断断续续写了快一个月，这里面东西还有好多，等之后再找时间补上。 0x01 UMA和NUMA模型1.1 UMA模型一致存储器访问（Uniform-Memory-Access，简称UMA）模型，一致性意指无论在什么时候，处理器只能为内存的每个">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://v1ckydxp.github.io/images/15701545708730.jpg">
<meta property="og:image" content="https://v1ckydxp.github.io/images/15701566481647.jpg">
<meta property="og:image" content="https://v1ckydxp.github.io/images/15701572975167.jpg">
<meta property="og:image" content="https://v1ckydxp.github.io/images/15702468118000.jpg">
<meta property="og:image" content="https://v1ckydxp.github.io/images/15702632405644.jpg">
<meta property="og:updated_time" content="2020-03-20T05:37:42.660Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux 内核物理页面内存分配">
<meta name="twitter:description" content="0x00 前言之前分析一个Linux内核的洞，需要对内存分配这块比较熟悉，这篇文章之前的学习笔记整理。以下所有的源码分析基于linux-4.20-rc3。这篇文件断断续续写了快一个月，这里面东西还有好多，等之后再找时间补上。 0x01 UMA和NUMA模型1.1 UMA模型一致存储器访问（Uniform-Memory-Access，简称UMA）模型，一致性意指无论在什么时候，处理器只能为内存的每个">
<meta name="twitter:image" content="https://v1ckydxp.github.io/images/15701545708730.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://v1ckydxp.github.io/archives/2019/11/09/2019-10-04-Linux内核页面分配/">





  <title>Linux 内核物理页面内存分配 | v1cky'blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">v1cky'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">few words,many deeds!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://v1ckydxp.github.io/archives/2019/11/09/2019-10-04-Linux内核页面分配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="v1cky01dxp">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="v1cky'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux 内核物理页面内存分配</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">
                2019-11-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-03-20T13:37:42+08:00">
                2020-03-20
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-kernel/" itemprop="url" rel="index">
                    <span itemprop="name">linux-kernel</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  37
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前分析一个Linux内核的洞，需要对内存分配这块比较熟悉，这篇文章之前的学习笔记整理。<br>以下所有的源码分析基于linux-4.20-rc3。这篇文件断断续续写了快一个月，这里面东西还有好多，等之后再找时间补上。</p>
<h2 id="0x01-UMA和NUMA模型"><a href="#0x01-UMA和NUMA模型" class="headerlink" title="0x01 UMA和NUMA模型"></a>0x01 UMA和NUMA模型</h2><h3 id="1-1-UMA模型"><a href="#1-1-UMA模型" class="headerlink" title="1.1 UMA模型"></a>1.1 UMA模型</h3><p>一致存储器访问（Uniform-Memory-Access，简称UMA）模型，一致性意指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值。物理存储器备所有处理器均匀共享。所有处理对所有存储内存有相同的访问时间。在Linux中，在这种模式下还是使用节点，但是时一个单独的节点，它包含了系统中的所有物理内存。</p>
<h3 id="1-2-NUMA模型"><a href="#1-2-NUMA模型" class="headerlink" title="1.2 NUMA模型"></a>1.2 NUMA模型</h3><p>非一致存储器访问（Nonuniform-Memory-Access，简称NUMA）模型，是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址。NUMA总是多处理器计算机,在这种模式下，给定CPU对不同的内存单元的访问时间可能不一样。</p>
<div align="center"> <img src="/images/15701545708730.jpg" alt="-w590"></div>


<p>在这种模式下。系统的物理内存被划分为多个节点(node)。在一个单独的节点内，任一给定的<code>CPU</code>访问页面所需的时间都是相同的。对于不同的<code>CPU</code>，访问时间可能不同。每个<code>node</code>被分配有本地存储器空间。所有<code>node</code>中的处理器都可以访问全部的物理存储器，但是访问本地<code>node</code>比访问其他<code>node</code>所需的时间要少的多。</p>
<h2 id="0x02-Linux物理内存组织形式"><a href="#0x02-Linux物理内存组织形式" class="headerlink" title="0x02 Linux物理内存组织形式"></a>0x02 Linux物理内存组织形式</h2><h3 id="2-1-内存组织形式"><a href="#2-1-内存组织形式" class="headerlink" title="2.1 内存组织形式"></a>2.1 内存组织形式</h3><p><code>Linux</code>把物理内存分为三个层次来管理：节点（node）、区域（zone）、页面（page）。<br><code>Linux</code>将<code>NUMA</code>中内存访问速度一致的部分划分为一个节点（node），然后每个节点（node）有分为多个区域（zone），每个区域（zone）又包含多个页面（page）。三者关系如下图：</p>
<div align="center"> <img src="/images/15701566481647.jpg" alt="-w541"><br><br></div><br><em> 每个节点（node）都有一个类型为<code>pg_data_t</code>的描述符，所有节点的描述符存放在一个单向链表里，由变量<code>pgdat_list</code>指向。系统中的每个结点都通过<code>pgdat_list</code>链表<code>pg_data_t-&gt;node_next</code>连接起来，该链接以<code>NULL</code>为结束标志。在UMA中，<code>pgdat_list</code>变量指向一个链表，该链表只有一个元素，这个元素就是节点0描述符，它被存放在<code>contig_page_data</code>变量中。
</em> 每个区域（zone）都有一个类型为<code>zone_t</code>的描述符，用以表示内存的某个范围，低端范围的16MB被描述为<code>ZONE_DMA</code>，某些工业标准体系结构中的(ISA)设备需要用到它，然后是可直接映射到内核的普通内存域<code>ZONE_NORMAL</code>，最后是超出了内核段的物理地址域<code>ZONE_HIGHMEM</code>，被称为高端内存。是系统中预留的可用内存空间, 不能被内核直接映射。<br><div align="center"><img src="/images/15701572975167.jpg" alt="-w780"><br></div>

<h3 id="2-2-相关数据结构"><a href="#2-2-相关数据结构" class="headerlink" title="2.2 相关数据结构"></a>2.2 相关数据结构</h3><h4 id="2-2-1-内存节点描述符-struct-pglist-data"><a href="#2-2-1-内存节点描述符-struct-pglist-data" class="headerlink" title="2.2.1 内存节点描述符 - struct pglist_data"></a>2.2.1 内存节点描述符 - struct pglist_data</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">//节点区域：在x86下，有，ZONE_HIGHMEM，ZONE_NORMAL，</span></span><br><span class="line">    <span class="comment">//ZONE_DMA;在x86_64,CPU中区域有DMA、DMA32和NORMAL三部分</span></span><br><span class="line">    <span class="comment">//管理当前节点zone描述符数组。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">//分配区域时的顺序，由函数free_area_init_core()调用mm/page_alloc.c 中函数build_zonelists()设置；</span></span><br><span class="line">    <span class="comment">/*页分配器使用的zonelist数据结构的数组，将所有节点的管理区按一定的关联链接成一个链表，分配内存时会按照链表的顺序进行分配</span></span><br><span class="line"><span class="comment">    它是zonelist结构的数组，长度为MAX_ZONELISTS。如果内核未配置NUMA，则长度为1，否则，长度为2。该数组中0号元素指定了备用的内存管理区链表，也就是当前系统中所有的zone。1号元素指定了当前节点中的管理区链表。除非分配内存时指定了GFP_THISNODE标志而采用本地内存节点上的zonelist，一般均采用备用zonelist。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="comment">//number of zone,usually in range of 1~3,not all zones have 3 zones.</span></span><br><span class="line">	<span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="comment">//first page address in array mem_map to this node</span></span><br><span class="line">    <span class="comment">//指向节点中所有页描述符的数组的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line">......</span><br><span class="line">	<span class="comment">//在numa架构中，页框会有两个下标，一个是在buddy系统中的下标，一个是在所有页框中的下标</span></span><br><span class="line">	<span class="comment">//比如在节点2中的页框1，在buddy系统中的下标是1，在所有的页框中的下标是1001,</span></span><br><span class="line">	<span class="comment">//该变量就是保存的该节点的第一个页框的下标，方便转换</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn; <span class="comment">//the start page frame  number to this node </span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes,该节点的所有物理页面，包括空洞（比如部分地址为外设I/O使用 */</span></span><br><span class="line">	<span class="keyword">int</span> node_id;<span class="comment">//节点ID，从0开始</span></span><br><span class="line">	<span class="comment">/* kswaped页换出守护进程使用的等待队列 */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="comment">/* 指针指向kswapd内核线程的进程描述符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	......</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lru_lock;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>每个结点都有一个内核线程kswapd，它的作用就是将进程或内核持有的，但是不常用的页交换到磁盘上，以腾出更多可用内存。</p>
<h4 id="2-2-2-管理区描述符-struct-zone"><a href="#2-2-2-管理区描述符-struct-zone" class="headerlink" title="2.2.2 管理区描述符 - struct zone"></a>2.2.2 管理区描述符 - struct zone</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros </span></span><br><span class="line"><span class="comment">		page_min,page_low,page_high反应了区域的空闲页面的数量</span></span><br><span class="line"><span class="comment">		page_min : zone中保留页的数量</span></span><br><span class="line"><span class="comment">		page_low : 回收页框使用的下界，同时也被管理区分配器作为阀值使用，一般这个数字是pages_min的5/4</span></span><br><span class="line"><span class="comment">		page_high : 回收页框使用的上界，同时也被管理区分配器作为阀值使用，一般这个数字是pages_min的3/2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//针对每个区域保存的物理页面数量，保证在任何情况下，内存分配都不会失败</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span><span class="comment">//指向该区域的节点pg_data_t</span></span><br><span class="line">	<span class="comment">/* 实现每CPU页框高速缓存，里面包含每个CPU的单页框的链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT </span></span><br><span class="line"><span class="comment">		那个zone_mem_map结构已经不存在，而是由 zone_start_pfn 地址来代替，</span></span><br><span class="line"><span class="comment">		通过这种方式查找出来的pfn是某个内存区域特有的！比如是ZONE_DMA/ZONE_NORMAL/ZONE_HIGHMEM的第一个pfn号码！</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line">    <span class="comment">/* managed_pages 是这个zone被Buddy管理的所有的page数目，</span></span><br><span class="line"><span class="comment">     * 计算的方式：</span></span><br><span class="line"><span class="comment">     *  managed_pages = present_pages - reserved_pages</span></span><br><span class="line"><span class="comment">     * 其中reserved_pages包括被Bootmem分配走的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		managed_pages;</span><br><span class="line"> 	<span class="comment">/* spanned_pages 是这个zone跨越的所有物理内存的page数目</span></span><br><span class="line"><span class="comment">     * 包括内存空洞，它的计算方式：</span></span><br><span class="line"><span class="comment">     *  spanned_pages = zone_end_pfn - zone_start_pfn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	   <span class="comment">/* present_pages 是这个zone在物理内存真实存在的所有page数目，</span></span><br><span class="line"><span class="comment">     * 它的计算方式：</span></span><br><span class="line"><span class="comment">     *  present_pages = spanned_pages - absent_pages</span></span><br><span class="line"><span class="comment">     *  其中absent_pages指的是内存空洞的page数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;<span class="comment">//区域的名字：DMA\DMA32\NORMAL\HIGHMEN\MOVEABLE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 在内存隔离中表示隔离的页框块数量 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">	<span class="comment">/*  伙伴算法分配使用的保存空闲页面的结构,标识出管理区中的空闲页框块，用于伙伴系统。 MAX_ORDER为11，分别代表包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续页框的链表 */</span></span><br><span class="line">	*/</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;<span class="comment">//spinlock防止对区域的并发访问</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>此管理区描述符中的实际把所有属于该管理区的页框保存在两个地方：struct free_area free_area[MAX_ORDER]和struct per_cpu_pageset __percpu * pageset。free_area是这个管理区的伙伴系统，而pageset是这个区的每CPU页框高速缓存。对管理区的理解需要结合伙伴系统和每CPU页框高速缓存</p>
<h4 id="2-2-3-页框描述符-struct-page"><a href="#2-2-3-页框描述符-struct-page" class="headerlink" title="2.2.3 页框描述符 - struct page"></a>2.2.3 页框描述符 - struct page</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line"><span class="comment">/*包含有很多信息，包括此页框属于的node结点号，此页框属于的zone号和此页框的属性。 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">	 * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 用于将此页描述符放入相应的链表，比如伙伴系统或者每CPU页框高速缓存。			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">			<span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS</span></span><br><span class="line"><span class="comment">		       用于页描述符，当页被插入页高速缓存中时使用，或者当页属于匿名区时使用  </span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">			<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">			 * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">			 * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">			 * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	<span class="comment">/* uses lru */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;	<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line">			<span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Second tail page of compound page */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page table pages */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;	<span class="comment">/* mapping */</span></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line">				<span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">			&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">			<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">			<span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> hmm_data;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment">		 * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment">		 * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment">		 * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment">		 * which are currently stored here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> active;		<span class="comment">/* SLAB */</span></span><br><span class="line">		<span class="keyword">int</span> units;			<span class="comment">/* SLOB */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h </span></span><br><span class="line"><span class="comment">		页框的引用计数，如果为-1，则此页框空闲，并可分配给任一进程或内核；</span></span><br><span class="line"><span class="comment">		如果大于或等于0，则说明页框被分配给了一个或多个进程，或用于存放内核数据。</span></span><br><span class="line"><span class="comment">		page_count()返回_count加1的值，也就是该页的使用者数目 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _refcount;</span><br><span class="line">......</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-每CPU页框高速缓存-struct-per-cpu-pages"><a href="#2-2-4-每CPU页框高速缓存-struct-per-cpu-pages" class="headerlink" title="2.2.4 每CPU页框高速缓存 - struct per_cpu_pages"></a>2.2.4 每CPU页框高速缓存 - struct per_cpu_pages</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> count;		<span class="comment">/* number of pages in the list */</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">		上界，当此CPU高速缓存中页框个数大于high，则会将batch个页框放回伙伴系统 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> high;	</span><br><span class="line">	<span class="comment">/* 在高速缓存中将要添加或被删去的页框个数 */</span>	</span><br><span class="line">	<span class="keyword">int</span> batch;		</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lists of pages, one per migrate type stored on the pcp-lists</span></span><br><span class="line"><span class="comment">	 	页框的链表，如果需要冷高速缓存，从链表尾开始获取页框，如果需要热高速缓存，从链表头开始获取页框 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-页面分配与回收API"><a href="#0x03-页面分配与回收API" class="headerlink" title="0x03 页面分配与回收API"></a>0x03 页面分配与回收API</h2><p>下图展示了内核内存分配回收的一些API函数：</p>
<p><div align="center"><img src="/images/15702468118000.jpg" alt="-w782"><br></div><br>所有的内存分配<code>API</code>函数最后都会调用<code>alloc_pages</code>函数，而<code>alloc_pages</code>函数的定义依赖于<code>NUMA</code>或者<code>UMA</code>架构。</p>
<h3 id="3-1-NUMA架构alloc-pages函数实现"><a href="#3-1-NUMA架构alloc-pages函数实现" class="headerlink" title="3.1 NUMA架构alloc_pages函数实现"></a>3.1 NUMA架构alloc_pages函数实现</h3><p>在<code>NUMA</code>架构下，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">503</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="number">504</span> <span class="function"><span class="keyword">extern</span> struct page *<span class="title">alloc_pages_current</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> order)</span></span>;</span><br><span class="line"><span class="number">505</span></span><br><span class="line"><span class="number">506</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">507 <span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">508 &#123;</span></span><br><span class="line"><span class="number">509</span>         <span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line"><span class="number">510</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>alloc_pages</code>函数这里会调用<code>alloc_pages_current</code>函数，具体的分配调用路径为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alloc_pages(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line">    --&gt; alloc_pages_current(gfp_mask, order)</span><br><span class="line">        --&gt; alloc_page_interleave(gfp, order, interleave_nodes(pol))</span><br><span class="line">        |    --&gt; __alloc_pages(gfp, order, nid)</span><br><span class="line">        |       --&gt; __alloc_pages_nodemask(gfp_mask, order, preferred_nid, <span class="literal">NULL</span>)</span><br><span class="line">        |</span><br><span class="line">        --&gt; __alloc_pages_nodemask(gfp, order,policy_node(gfp, pol, numa_node_id()),policy_nodemask(gfp, pol))</span><br></pre></td></tr></table></figure>
<p>根据内存分配策略选择最终内存分配函数<code>__alloc_pages_nodemask</code>。</p>
<h3 id="3-2-UMA架构alloc-pages函数实现"><a href="#3-2-UMA架构alloc-pages函数实现" class="headerlink" title="3.2 UMA架构alloc_pages函数实现"></a>3.2 UMA架构alloc_pages函数实现</h3><p>在<code>UMA</code>架构下，具体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">514</span> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="number">515</span> <span class="meta">#<span class="meta-keyword">define</span> alloc_pages(gfp_mask, order) \</span></span><br><span class="line"><span class="number">516</span>                 alloc_pages_node(numa_node_id(), gfp_mask, order)</span><br></pre></td></tr></table></figure></p>
<p>具体的分配调用路径为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloc_pages(gfp_mask, order)</span><br><span class="line">    --&gt; alloc_pages_node(numa_node_id(), gfp_mask, order)</span><br><span class="line">        --&gt; __alloc_pages_node(nid, gfp_mask, order)</span><br><span class="line">            --&gt; __alloc_pages(gfp_mask, order, nid)</span><br><span class="line">                --&gt; __alloc_pages_nodemask(gfp_mask, order, preferred_nid, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>
<p>最后会调用<code>__alloc_pages_nodemask</code>函数，该函数被称为伙伴算法的心脏，它处理实质性的内存分配。 </p>
<h2 id="0x04-alloc-pages-nodemask-函数源码分析"><a href="#0x04-alloc-pages-nodemask-函数源码分析" class="headerlink" title="0x04 __alloc_pages_nodemask()函数源码分析"></a>0x04 __alloc_pages_nodemask()函数源码分析</h2><p><code>__alloc_pages_nodemask</code>函数位于<code>mm/kasan/page_alloc.c</code>。在详细分析之前先将里面要用到的一些重要标志放在前面说明。内核在进行内存分配过程中，会用到一些标志来辅助该过程。</p>
<h3 id="4-1-water-mark–水准"><a href="#4-1-water-mark–水准" class="headerlink" title="4.1 water_mark–水准"></a>4.1 water_mark–水准</h3><p>当系统中的空闲内存不断被消耗，<code>kswapd</code>守护进程就会被唤醒去释放页面。若内存空闲率很低，<code>kswapd</code>就会同步地释放内存，有时称为直接回收（direct-reclaim）路径。<br>每个<code>zone</code>有三个<code>water mark</code>:<code>page_low</code>、<code>page_min</code>、<code>page_high</code>。关于<code>zone_water_mark</code>定义位于文件<code>include/linux/mmzone.h</code>处<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">265</span> <span class="keyword">enum</span> zone_watermarks &#123;</span><br><span class="line"><span class="number">266</span>         WMARK_MIN,</span><br><span class="line"><span class="number">267</span>         WMARK_LOW,</span><br><span class="line"><span class="number">268</span>         WMARK_HIGH,</span><br><span class="line"><span class="number">269</span>         NR_WMARK</span><br><span class="line"><span class="number">270</span> &#125;;</span><br><span class="line"><span class="number">271</span></span><br><span class="line"><span class="number">272</span> <span class="meta">#<span class="meta-keyword">define</span> min_wmark_pages(z) (z-&gt;watermark[WMARK_MIN])</span></span><br><span class="line"><span class="number">273</span> <span class="meta">#<span class="meta-keyword">define</span> low_wmark_pages(z) (z-&gt;watermark[WMARK_LOW])</span></span><br><span class="line"><span class="number">274</span> <span class="meta">#<span class="meta-keyword">define</span> high_wmark_pages(z) (z-&gt;watermark[WMARK_HIGH])</span></span><br></pre></td></tr></table></figure></p>
<p>区域水准和内存空闲页面的关系如下图：</p>
<p><div align="center"><img src="/images/15702632405644.jpg" alt="-w744"><br></div><br>在不同的空闲页面的水准上，会采取不同的动作：</p>
<ul>
<li><strong>WMARK_MIN</strong>: 当空闲页面的数量降到<code>WMARK_MIN</code>时，<code>buddy</code>分配器会唤醒 <code>kswapd</code> 守护进程以同步的方式进行直接内存回收（direct-reclaim）。</li>
<li><strong>WMARK_LOW</strong>: 当空闲页面的数量降到WMARK_LOW时，<code>buddy</code>分配器会唤醒 <code>kswapd</code> 守护进程进行内存回收。</li>
<li><strong>WMARK_HIGH</strong>: 此时<code>kswapd</code>进程会进入休眠</li>
</ul>
<h3 id="4-2-gfp-mask"><a href="#4-2-gfp-mask" class="headerlink" title="4.2 gfp_mask"></a>4.2 gfp_mask</h3><p>在<code>__alloc_pages_nodemask</code>函数的参数中有两个比较重要的，一个是<code>order</code>，代表分配物理页面数量的阶，物理页面分配必须都是2的<code>order</code>次幂。<br><code>gfp_mask</code>参数为内存分配的分配掩码。分配掩码分为两部分：内存域修饰符（占低4位）、内存分配标志（从低5位开始）。<br>内存<code>zone</code>的类型有：<code>ZONE_DMA</code>、<code>ZONE_DMA32</code>、<code>ZONE_NORMAL</code>、<code>ZONE_HIGHMEM</code>、<code>ZONE_MOVABLE</code>。而内存域的修饰符只有以下4种，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_DMA              0x01u</span></span><br><span class="line"><span class="number">20</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_HIGHMEM          0x02u</span></span><br><span class="line"><span class="number">21</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_DMA32            0x04u</span></span><br><span class="line"><span class="number">22</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_MOVABLE          0x08u</span></span><br></pre></td></tr></table></figure>
<p>没有<code>ZONE_NORMAL</code>的修饰符是因为<code>ZONE_NORMAL</code>是默认的修饰符。</p>
<h4 id="4-2-1-内存域修饰符与内存分配器扫描内存域顺序的关系"><a href="#4-2-1-内存域修饰符与内存分配器扫描内存域顺序的关系" class="headerlink" title="4.2.1 内存域修饰符与内存分配器扫描内存域顺序的关系"></a>4.2.1 内存域修饰符与内存分配器扫描内存域顺序的关系</h4><table>
<thead>
<tr>
<th>内存域修饰符</th>
<th>扫描内存域顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认</td>
<td>ZONE_NORMAL-&gt;ZONE_DMA32-&gt;ZONE_DMA</td>
</tr>
<tr>
<td>___GFP_DMA32</td>
<td>ZONE_DMA32-&gt;ZONE_DMA</td>
</tr>
<tr>
<td>___GFP_DMA</td>
<td>ZONE_DMA</td>
</tr>
<tr>
<td><strong>_GFP_DMA&amp;_</strong>GFP_HIGHMEM</td>
<td>ZONE_DMA</td>
</tr>
<tr>
<td>___GFP_HIGHMEM</td>
<td>ZONE_HIGHMEN-&gt;ZONE_MORMAL-&gt;ZONE_DMA32-&gt;ZONE_DMA</td>
</tr>
</tbody>
</table>
<h4 id="4-2-2-内存分配标志"><a href="#4-2-2-内存分配标志" class="headerlink" title="4.2.2 内存分配标志"></a>4.2.2 内存分配标志</h4><p>   <code>gfp_mask</code>分配除了低4位内存域修饰符外，其他的位的一部分做为了内存分配标识，但是这些标志一般都是组合使用，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">23</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_RECLAIMABLE      0x10u</span></span><br><span class="line"> <span class="number">24</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_HIGH             0x20u</span></span><br><span class="line"> <span class="number">25</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_IO               0x40u</span></span><br><span class="line"> <span class="number">26</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_FS               0x80u</span></span><br><span class="line"> <span class="number">27</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_WRITE            0x100u</span></span><br><span class="line"> <span class="number">28</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NOWARN           0x200u</span></span><br><span class="line"> <span class="number">29</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_RETRY_MAYFAIL    0x400u</span></span><br><span class="line"> <span class="number">30</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NOFAIL           0x800u</span></span><br><span class="line"> <span class="number">31</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NORETRY          0x1000u</span></span><br><span class="line"> <span class="number">32</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_MEMALLOC         0x2000u</span></span><br><span class="line"> <span class="number">33</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_COMP             0x4000u</span></span><br><span class="line"> <span class="number">34</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_ZERO             0x8000u</span></span><br><span class="line"> <span class="number">35</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NOMEMALLOC       0x10000u</span></span><br><span class="line"> <span class="number">36</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_HARDWALL         0x20000u</span></span><br><span class="line"> <span class="number">37</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_THISNODE         0x40000u</span></span><br><span class="line"> <span class="number">38</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_ATOMIC           0x80000u</span></span><br><span class="line"> <span class="number">39</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_ACCOUNT          0x100000u</span></span><br><span class="line"> <span class="number">40</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_DIRECT_RECLAIM   0x200000u</span></span><br><span class="line"> <span class="number">41</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_KSWAPD_RECLAIM   0x400000u</span></span><br><span class="line"> <span class="number">42</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"> <span class="number">43</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NOLOCKDEP        0x800000u</span></span><br><span class="line"> <span class="number">44</span> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="number">45</span> <span class="meta">#<span class="meta-keyword">define</span> ___GFP_NOLOCKDEP        0</span></span><br><span class="line"> <span class="number">46</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### <span class="number">4.3</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> 结构体</span></span><br><span class="line"><span class="class">该结构体封装了内存分配要用到的一些参数标识。</span></span><br><span class="line"><span class="class">```<span class="title">c</span></span></span><br><span class="line"><span class="class">117 <span class="title">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line"><span class="comment">//当perferred_zone上没有合适的页可以分配时，就要按zonelist中的顺序扫描该zonelist中备用zone列表，一个个的试用,通常的顺序是high-&gt;normal-&gt;dma</span></span><br><span class="line"><span class="number">118</span>         <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line"><span class="comment">//表示节点的mask，这是个bit数组，数组元素的值标识着对应的结点是否可以分配内存</span></span><br><span class="line"><span class="number">119</span>         <span class="keyword">nodemask_t</span> *nodemask;</span><br><span class="line"><span class="comment">//表示从high_zoneidx后找到的合适的zone，一般会从该zone分配；</span></span><br><span class="line"><span class="comment">//如果分配失败，就会从zonelist在找一个preferred_zoneref = 合适的zone</span></span><br><span class="line"><span class="number">120</span>         <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="comment">//迁移类型，在zone-&gt;free_area.free_list[XXX] 作为分配下标使用，这个是用来反碎片化的，修改了以前的</span></span><br><span class="line"><span class="comment">//free_area结构体，在该结构体中再添加了一个数组，该数组以迁移类型为下标，每个数组元素都挂了对应迁移类型的页链表</span></span><br><span class="line"><span class="number">121</span>         <span class="keyword">int</span> migratetype;</span><br><span class="line"><span class="comment">//表示内存分配时，所能分配的最高zone，一般从high-&gt;normal-&gt;dma的顺序来遍历，</span></span><br><span class="line"><span class="number">122</span>         <span class="keyword">enum</span> zone_type high_zoneidx;</span><br><span class="line"><span class="number">123</span>         <span class="keyword">bool</span> spread_dirty_pages;</span><br><span class="line"><span class="number">124</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-alloc-pages-nodemask源码分析"><a href="#4-4-alloc-pages-nodemask源码分析" class="headerlink" title="4.4  __alloc_pages_nodemask源码分析"></a>4.4  __alloc_pages_nodemask源码分析</h3><p>该函数定义在<code>mm/page_alloc.c</code>文件中，该函数实现的功能主要有以下三点：</p>
<ol>
<li>进行一些必要的<code>check</code>，并将之后进行内存分配所要用到的一些标识进行初始化。</li>
<li>尝试快分配 - <code>get_page_from_freelist()</code></li>
<li>若第2步失败，尝试慢分配 - <code>__alloc_pages_slowpath()</code></li>
</ol>
<h4 id="4-4-1-前期check-amp-struct-alloc-context结构体变量ac初始化"><a href="#4-4-1-前期check-amp-struct-alloc-context结构体变量ac初始化" class="headerlink" title="4.4.1 前期check &amp; struct alloc_context结构体变量ac初始化"></a>4.4.1 前期check &amp; struct alloc_context结构体变量ac初始化</h4><p>首先会判断参数<code>order</code>是否大于<code>MAX_ORDER</code>，<code>MAX_ORDER</code>定义为<code>11</code>，<code>order</code>表示<code>free_list</code>数组的下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4362</span>         <span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line"><span class="number">4363</span>                 WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line"><span class="number">4364</span>                 <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">4365</span>         &#125;</span><br></pre></td></tr></table></figure>
<p>上面是做一些基本的<code>check</code> ,然后调用<code>prepare_alloc_pages（）</code>函数对<code>struct alloc_context</code>结构体变量<code>ac</code>进行初始化赋值。跟进该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4299</span> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4300</span>                 <span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4301</span>                 struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_mask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4302</span>                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function">4303 </span>&#123;</span><br><span class="line"><span class="comment">//获取内存分配时，所能分配内存的最高zone，通常的顺序是：HIGHMEN-&gt;NORMAL-&gt;DMA。high_zoneidx是_zonerefs数组的下标，</span></span><br><span class="line"><span class="number">4304</span>         ac-&gt;high_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line"><span class="comment">//当perferred_zone上没有合适的页可以分配时，就要按zonelist中的顺序扫描该zonelist中备用zone列表，一个个的试用</span></span><br><span class="line"><span class="number">4305</span>         ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line"><span class="number">4306</span>         ac-&gt;nodemask = nodemask;</span><br><span class="line"><span class="comment">//根据gfp_mask标识转换成相应的migratetype</span></span><br><span class="line"><span class="number">4307</span>         ac-&gt;migratetype = gfpflags_to_migratetype(gfp_mask);</span><br><span class="line"><span class="comment">//检查cpusets功能是否开启，这个是一个cgroup的子模块, 如果没有设置nodemask就会用cpusets配置的cpuset_current_mems_allowed来限制在哪个node上分配，这个也是在NUMA结构当中才会有用的.</span></span><br><span class="line"><span class="number">4309</span>         <span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line"><span class="number">4310</span>                 *alloc_mask |= __GFP_HARDWALL;</span><br><span class="line"><span class="number">4311</span>                 <span class="keyword">if</span> (!ac-&gt;nodemask)</span><br><span class="line"><span class="number">4312</span>                         ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line"><span class="number">4313</span>                 <span class="keyword">else</span></span><br><span class="line"><span class="number">4314</span>                         *alloc_flags |= ALLOC_CPUSET;</span><br><span class="line"><span class="number">4315</span>         &#125;</span><br><span class="line"><span class="number">4316</span></span><br><span class="line"><span class="number">4317</span>         fs_reclaim_acquire(gfp_mask);</span><br><span class="line"><span class="number">4318</span>         fs_reclaim_release(gfp_mask);</span><br><span class="line"><span class="comment">//might_sleep_if,判断gfp_mask &amp; __GFP_DIRECT_RECLAIM), 表示当前内存压力比较大需要直接回收内存, 会循环睡眠同步等待页可用, </span></span><br><span class="line"><span class="number">4320</span>         might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"><span class="comment">//而might_sleep_if是一个debug函数,标记当前函数在if为true的时候表示可能会进入睡眠, 如果当前调用进入了一个不可睡眠的上下文就会报错. should_fail_alloc_page会做一些预检查, 一些无法分配的条件会直接报错.</span></span><br><span class="line"><span class="number">4322</span>         <span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line"><span class="number">4323</span>                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//判断是否开启了连续内存分配器，并且要求迁移类型为可移动</span></span><br><span class="line"><span class="number">4325</span>         <span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA) &amp;&amp; ac-&gt;migratetype == MIGRATE_MOVABLE)</span><br><span class="line"><span class="number">4326</span>                 *alloc_flags |= ALLOC_CMA;</span><br><span class="line"><span class="number">4327</span></span><br><span class="line"><span class="number">4328</span>         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">4329</span> &#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>__alloc_pages_nodemask</code>函数，接着调用f<code>inalise_ac(gfp_mask, &amp;ac)</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4331</span> <span class="comment">/* Determine whether to spread dirty pages and what the first usable zone */</span></span><br><span class="line"><span class="number">4332</span> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">finalise_ac</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, struct alloc_context *ac)</span></span></span><br><span class="line"><span class="function">4333 </span>&#123;</span><br><span class="line"><span class="number">4334</span>         <span class="comment">/* Dirty zone balancing only done in the fast path */</span></span><br><span class="line"><span class="number">4335</span>         ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"><span class="number">4336</span></span><br><span class="line"><span class="number">4337</span>         <span class="comment">/*</span></span><br><span class="line"><span class="comment">4338          * The preferred zone is used for statistics but crucially it is</span></span><br><span class="line"><span class="comment">4339          * also used as the starting point for the zonelist iterator. It</span></span><br><span class="line"><span class="comment">4340          * may get reset for allocations that ignore memory policies.</span></span><br><span class="line"><span class="comment">4341          */</span></span><br><span class="line"><span class="number">4342</span>         ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line"><span class="number">4343</span>                                         ac-&gt;high_zoneidx, ac-&gt;nodemask);</span><br><span class="line"><span class="number">4344</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>finalise_ac</code>函数会对<code>ac-&gt;preferred_zoneref</code> 进行赋值，即可用来分配内存的<code>zone</code>。如何来查找可用来内存分配的<code>zone</code>，在下面详细说明一下。<br><code>first_zones_zonelist</code>函数会根据<code>zonelist</code>，<code>highidx</code>,<code>nodemask</code>这几个参数，最终选择一个<code>zone</code>最为第一个可用来内存分配的<code>zone</code>。内存分配的<code>zone</code>的寻找，是通过遍历<code>zonelist</code>的<code>_zonerefs</code>数组来做的，<code>struct zonelist</code>结构体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">590</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">591  * This struct contains information about a zone in a zonelist. It is stored</span></span><br><span class="line"><span class="comment">592  * here to avoid dereferences into large structures and lookups of tables</span></span><br><span class="line"><span class="comment">593  */</span></span><br><span class="line"><span class="number">594</span> <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="number">595</span>         <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>      <span class="comment">/* Pointer to actual zone */</span></span><br><span class="line"><span class="number">596</span>         <span class="keyword">int</span> zone_idx;           <span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line"><span class="number">597</span> &#125;;</span><br><span class="line"><span class="number">598</span> .......</span><br><span class="line"><span class="number">613</span> <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="number">614</span>         <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line"><span class="number">615</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>_zonerefs</code>数组的大小为<code>MAX_ZONES_PER_ZONELIST + 1</code>，<code>MAX_ZONES_PER_ZONELIST</code>的值取决于最大节点数和每个节点最大<code>zone</code>数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">575</span> <span class="comment">/* Maximum number of zones on a zonelist */</span></span><br><span class="line"><span class="number">576</span> <span class="meta">#<span class="meta-keyword">define</span> MAX_ZONES_PER_ZONELIST (MAX_NUMNODES * MAX_NR_ZONES)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="meta">#<span class="meta-keyword">define</span> MAX_NR_ZONES 5 <span class="comment">/* __MAX_NR_ZONES */</span></span></span><br></pre></td></tr></table></figure>
<p>查找最大能分配的<code>zone</code>的逻辑是在<code>zonelist</code>中找到第一个<code>idx</code>比<code>highidx</code>小的<code>zone</code>返回作为内存分配的首先<code>zone</code>。<br>函数调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first_zones_zonelist(ac-&gt;zonelist,ac-&gt;high_zoneidx, ac-&gt;nodemask)</span><br><span class="line">    --&gt; first_zones_zonelist(struct zonelist *zonelist,<span class="keyword">enum</span> zone_type highest_zoneidx,<span class="keyword">nodemask_t</span> *nodes)</span><br><span class="line">        --&gt; next_zones_zonelist(struct zoneref *z,  <span class="keyword">enum</span> zone_type highest_zoneidx,  <span class="keyword">nodemask_t</span> *nodes)</span><br></pre></td></tr></table></figure>
<p>最终的查找逻辑是在<code>next_zones_zonelist</code>函数中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">989</span> <span class="keyword">static</span> __<span class="function">always_inline struct zoneref *<span class="title">next_zones_zonelist</span><span class="params">(struct zoneref *z,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">990</span>                                         <span class="keyword">enum</span> zone_type highest_zoneidx,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">991</span>                                         <span class="keyword">nodemask_t</span> *nodes)</span></span></span><br><span class="line"><span class="function">992 </span>&#123;</span><br><span class="line"><span class="number">993</span>         <span class="keyword">if</span> (likely(!nodes &amp;&amp; zonelist_zone_idx(z) &lt;= highest_zoneidx))</span><br><span class="line"><span class="number">994</span>                 <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">995</span>         <span class="keyword">return</span> __next_zones_zonelist(z, highest_zoneidx, nodes);</span><br><span class="line"><span class="number">996</span> &#125;</span><br></pre></td></tr></table></figure>
<p>由于highest_zoneidx是最大的区域，所以只要小于该区域的zone就是首选zone。</p>
<h4 id="4-4-2-快分配-–-get-page-from-freelist"><a href="#4-4-2-快分配-–-get-page-from-freelist" class="headerlink" title="4.4.2 快分配 –  get_page_from_freelist"></a>4.4.2 快分配 –  get_page_from_freelist</h4><p>到这里内存分配需用到的参数标识都初始化完了，回到<code>__alloc_pages_nodemask</code>函数，接下来会调用关键函数<code>get_page_from_freelist</code>进程快速内存分配。如果分配失败，会继续尝试其他途径分配所需内存，也叫做慢分配。<br>具体的源码比较多，下面就简单的说明下该函数的一些操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 首先进入一个<span class="keyword">for</span>循环，遍历ac-&gt;zonelist中不大于zc-&gt;highidx的所有zone：for_next_zone_zonelist_nodemask</span><br><span class="line"><span class="number">2.</span> 接下来会检查是否开启了cpuset而且设置了ALLOC_CPUSET标志就检查看当前CPU是否允许在内存域zone所在结点中分配内存。</span><br><span class="line"><span class="number">3.</span> 检查ac-&gt;spread_dirty_pages的值，ac-&gt;spread_dirty_pages不为零标识本次内存分配用于写，可能增加赃页数。并且检查当前zone所在节点的脏页面是否超标，若超标则跳过，遍历下一个zone。</span><br><span class="line"><span class="number">4.</span> 获取该zone的水准，并检查该zone的空闲页面时候在水准之上。若该zone的空闲页面在水准之下，则会进行空闲页回收，在该zone设置了水准标志的前提下，并且设置了可回收标志。</span><br><span class="line"><span class="number">5.</span> 在上面内存回收之后，水准满足要求，或者没有设置水准标志，会尝试在该zone进行内存分配。调用rmqueue函数尝试分配。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3359</span> <span class="comment">//执行到这里表示选择的zone有空闲内存</span></span><br><span class="line"><span class="number">3360</span> try_this_zone:</span><br><span class="line"><span class="number">3361</span>                 <span class="comment">//尝试内存分配</span></span><br><span class="line"><span class="number">3362</span>                 page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line"><span class="number">3363</span>                                 gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="number">3364</span>                 <span class="keyword">if</span> (page) &#123;</span><br><span class="line"><span class="number">3365</span></span><br></pre></td></tr></table></figure>
<p>执行到这块代码，代表当前<code>zone</code>有空闲内存，调用函数<code>rmqueue</code>函数尝试内存分配。</p>
<h5 id="4-4-2-1-rmqueue"><a href="#4-4-2-1-rmqueue" class="headerlink" title="4.4.2.1 rmqueue"></a>4.4.2.1 rmqueue</h5><p><code>rmqueue</code>函数的作用是从当前的<code>zone</code>分配空闲页面。分配时存在三种情况。</p>
<ol>
<li>当<code>order==0</code>，表示分配单页，这个时候调用<code>rmqueue_pcplist()</code>函数分配，即从冷热页中找。</li>
<li>如果<code>order</code>不为0，并且设置了<code>ALLOC_HARDER</code>标志，表示一次高优先级的分配。调用<code>__rmqueue_smallest()</code>函数，从前一类型为<code>MIGRATE_HIGHATOMIC</code>的链表中去分配。<code>MIGRATE_HIGHATOMIC</code>类型的页面用于一些紧急的情况下的内存分分配。</li>
<li>如果前面的情况都不是，则调用<code>__rmqueue()</code>函数从伙伴系统中按照指定迁移类型的链表中去分配。</li>
<li>如果在指定迁移类型链表中仍然没有就尝试到其他迁移类型中取偷取。</li>
</ol>
<p>具体的调用流程为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rmqueue（）--&gt; <span class="keyword">if</span>(order==<span class="number">0</span>) --&gt; rmqueue_pcplist()<span class="comment">//分配单页的情况</span></span><br><span class="line">          |</span><br><span class="line">          --&gt; <span class="keyword">if</span>(alloc_flags &amp; ALLOC_HARDER) --&gt; __rmqueue_smallest()<span class="comment">//进行高优先级分配</span></span><br><span class="line">          |</span><br><span class="line">          --&gt; __rmqueue()<span class="comment">//除了前面两种情况</span></span><br></pre></td></tr></table></figure>
<h5 id="4-4-2-2-rmqueue-pcplist"><a href="#4-4-2-2-rmqueue-pcplist" class="headerlink" title="4.4.2.2 rmqueue_pcplist()"></a>4.4.2.2 rmqueue_pcplist()</h5><p>o<code>rder==0</code>,分配冷热页，首先取出当前<code>CPU</code>的<code>pcp</code>，根据迁移类型取出对应链表<code>pcp-&gt;list</code>，然后调用<code>__rmqueue_pcplist</code>函数分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2970</span>         pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line"><span class="number">2971</span>         <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line"><span class="number">2972</span>         page = __rmqueue_pcplist(zone,  migratetype, pcp, <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>__rmqueue_pcplist</code>函数会判断传进来的指定类型的链表list是否为空，若为空，则从伙伴系统中分配一批放到<code>pcp-&gt;lists[migratetype]</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2943</span>                 <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line"><span class="number">2944</span></span><br><span class="line"><span class="comment">//如果指定类型链表为空就从伙伴系统中分配一批（pcp-&gt;batch）放到pcp-&gt;lists[migratetype]中</span></span><br><span class="line"><span class="number">2946</span>                         pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line"><span class="number">2947</span>                                         pcp-&gt;batch, <span class="built_in">list</span>,</span><br><span class="line"><span class="number">2948</span>                                         migratetype);</span><br></pre></td></tr></table></figure>
<p>然后从链表头中取一页，并将该页从<code>pcp-&gt;lists[migratetype]</code>中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2953</span>                 page = list_first_entry(<span class="built_in">list</span>, struct page, lru);</span><br><span class="line"><span class="number">2954</span>                 list_del(&amp;page-&gt;lru);</span><br><span class="line"><span class="number">2955</span>                 pcp-&gt;count--;</span><br></pre></td></tr></table></figure>
<h5 id="4-4-2-3-rmqueue-smallest"><a href="#4-4-2-3-rmqueue-smallest" class="headerlink" title="4.4.2.3 __rmqueue_smallest()"></a>4.4.2.3 __rmqueue_smallest()</h5><p>函数<code>__rmqueue_smallest</code>从指定迁移类型<code>migratetype</code>中去分配<code>order</code>阶的页块。如果<code>order</code>阶对应的链表没有空闲块就从更大阶的链表中去分配，将更大的页块拆解将剩余部分挂到对应<code>order</code>的链表中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1948</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">1949  * Go through the free lists for the given migratetype and remove</span></span><br><span class="line"><span class="comment">1950  * the smallest available page from the freelists</span></span><br><span class="line"><span class="comment">1951  */</span></span><br><span class="line"><span class="number">1952</span> <span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="number">1953</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="title">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">1954                                                 <span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">1955 &#123;</span></span><br><span class="line"><span class="number">1956</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> current_order;</span><br><span class="line"><span class="number">1957</span>         <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="number">1958</span>         <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="number">1959</span></span><br><span class="line"><span class="number">1960</span>         <span class="comment">/* Find a page of the appropriate size in the preferred list</span></span><br><span class="line"><span class="comment">1961          *从指定阶到MAX_ORDER的伙伴链表中去查找迁移类型为migratetype的空闲页块*/</span></span><br><span class="line"><span class="number">1962</span>         <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line"><span class="number">1963</span>                 area = &amp;(zone-&gt;free_area[current_order]);<span class="comment">//取order阶的free_area</span></span><br><span class="line"><span class="number">1964</span>                 page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line"><span class="number">1965</span>                                                         struct page, lru);<span class="comment">//取free_area中指定migratetype的页块</span></span><br><span class="line"><span class="number">1966</span>                 <span class="keyword">if</span> (!page)</span><br><span class="line"><span class="number">1967</span>                         <span class="keyword">continue</span>;<span class="comment">//如果指定order的free_area-&gt;free_list[migratetype]为空，则从更大的阶的area取获取页块</span></span><br><span class="line"><span class="number">1968</span>                 list_del(&amp;page-&gt;lru);<span class="comment">//将页块从对应阶的链表中删除</span></span><br><span class="line"><span class="number">1969</span>                 rmv_page_order(page);<span class="comment">//清楚伙伴系统标志，设置页阶为0</span></span><br><span class="line"><span class="number">1970</span>                 area-&gt;nr_free--;<span class="comment">//对应阶的free_area中的空闲块的数量减一</span></span><br><span class="line"><span class="number">1971</span>                 <span class="comment">//将current_order阶的页块拆成小块，并将小块放到对应的阶的链表中去</span></span><br><span class="line"><span class="number">1972</span>                 expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line"><span class="number">1973</span>                 <span class="comment">//设置页的迁移类型为page-&gt;index = migratetype</span></span><br><span class="line"><span class="number">1974</span>                 set_pcppage_migratetype(page, migratetype);</span><br><span class="line"><span class="number">1975</span>                 <span class="keyword">return</span> page;</span><br><span class="line"><span class="number">1976</span>         &#125;</span><br><span class="line"><span class="number">1977</span></span><br><span class="line"><span class="number">1978</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">1979</span> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-4-2-4-rmqueue"><a href="#4-4-2-4-rmqueue" class="headerlink" title="4.4.2.4 __rmqueue()"></a>4.4.2.4 __rmqueue()</h5><p><code>__rmqueue</code>函数会首先调用<code>__rmqueue_smallest</code>函数从指定迁移类型中分配<code>order</code>阶的页块，在<code>__rmqueue_smallest</code>函数分配失败后，会尝试从伙伴系统的备选迁移类中盗取页。调用<code>__rmqueue_smallest</code>函数分配空闲页的逻辑在上面已经分析了，下面主要分析<code>fallback</code>过程。</p>
<p>在详细分析<code>alloc_fallbacks</code>函数之前，首先看一下备用迁移类型表，定义在<code>mm/page_alloc.c</code>文件中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1982</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">1983  * This array describes the order lists are fallen back to when</span></span><br><span class="line"><span class="comment">1984  * the free lists for the desirable migrate type are depleted</span></span><br><span class="line"><span class="comment">1985  */</span></span><br><span class="line"><span class="number">1986</span> <span class="keyword">static</span> <span class="keyword">int</span> fallbacks[MIGRATE_TYPES][<span class="number">4</span>] = &#123;</span><br><span class="line"><span class="number">1987</span>         [MIGRATE_UNMOVABLE]   = &#123; MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line"><span class="number">1988</span>         [MIGRATE_RECLAIMABLE] = &#123; MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line"><span class="number">1989</span>         [MIGRATE_MOVABLE]     = &#123; MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES &#125;,</span><br><span class="line"><span class="number">1990</span> #ifdef CONFIG_CMA</span><br><span class="line"><span class="number">1991</span>         [MIGRATE_CMA]         = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="number">1992</span> #endif</span><br><span class="line"><span class="number">1993</span> #ifdef CONFIG_MEMORY_ISOLATION</span><br><span class="line"><span class="number">1994</span>         [MIGRATE_ISOLATE]     = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="number">1995</span> #endif</span><br><span class="line"><span class="number">1996</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是一个二维数组，该数组描绘的是当指定迁移类型分配无法满足时，<code>fallback</code>时选择的迁移类型遍历的前后顺序。</p>
<p><code>__rmqueue_cma_fallback</code>函数的处理根据编译选项而定，这里不做分析，具体分析<code>__rmqueue_fallback</code>函数。该函数的具体处理逻辑如下：</p>
<ul>
<li><strong>循环取出fallbacks[migratetype][i]备用迁移类型，根据该信息和current_order去指定的列表寻找页块。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2397</span>         <span class="keyword">for</span> (current_order = MAX_ORDER - <span class="number">1</span>; current_order &gt;= order;</span><br><span class="line"><span class="number">2398</span>                                 --current_order) &#123;</span><br><span class="line"><span class="number">2399</span>                 area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line"><span class="number">2400</span> <span class="comment">//循环取出fallbacks[migratetype][i]备用迁移类型，根据该信息和current_order尝试找出合适盗取页块，并返回迁移类型</span></span><br><span class="line"><span class="number">2401</span>                 fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line"><span class="number">2402</span>                                 start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line"><span class="number">2403</span>                 <span class="keyword">if</span> (fallback_mt == <span class="number">-1</span>)<span class="comment">//如果没有找到合适的盗取页块，尝试下一个order</span></span><br><span class="line"><span class="number">2404</span>                         <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">2405</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>find_suitabl _fallback</code>函数会根据参数<code>current_order</code>和<code>start_migratetype</code>，首先判断<code>current_order</code>的<code>area</code>是否有空闲页，若有空闲页，则根据<code>start_migratetype</code>迁移类型循环取出<code>fallbacks[start_migratetype][i]</code>数组中的备用迁移类型<code>fallback_mt</code>，并判断<code>area-&gt;free_list[fallback_mt]</code>是否有空闲块。并且判断是否可以进行页块盗取，若满足的条件1）<code>order &gt;= pageblock_order/2</code>；2）迁移类型为<code>MIGRATE_RECLAIMABLE</code>；3）迁移类型为<code>MIGRATE_UNMOVABLE</code>，就可以进行盗取。</p>
</blockquote>
<ul>
<li><strong>当所请求的迁移类型为可移动时，最好的做法是窃取和拆分最小的可用页块而不是最大的可用页块，因为即使下次请求可移动页块fall back时不是这块页块时，也不会造成永久性碎片。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2423</span> find_smallest:</span><br><span class="line"><span class="number">2424</span>         <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER;</span><br><span class="line"><span class="number">2425</span>                                                         current_order++) &#123;</span><br><span class="line"><span class="number">2426</span>                 area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line"><span class="number">2427</span>                 fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line"><span class="number">2428</span>                                 start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line"><span class="number">2429</span>                 <span class="keyword">if</span> (fallback_mt != <span class="number">-1</span>)</span><br><span class="line"><span class="number">2430</span>                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">2431</span>         &#125;</span><br><span class="line"><span class="number">2432</span></span><br></pre></td></tr></table></figure>
<p>从请求的页块的阶开始遍历当前<code>zone</code>的<code>free_area</code>，直到找到一个最小的可用页块。</p>
<ul>
<li><strong>当找到合适的页块后，就会进行页块的盗取或借用。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2439</span> do_steal:</span><br><span class="line"><span class="number">2440</span>         page = list_first_entry(&amp;area-&gt;free_list[fallback_mt],</span><br><span class="line"><span class="number">2441</span>                                                         struct page, lru);</span><br><span class="line"><span class="number">2442</span> <span class="comment">//这里找到合适的页块，该函数会判断是直接盗取（改变整个页块的迁移类型）还是借用（仅分配但不改变页块迁移类型）</span></span><br><span class="line"><span class="number">2443</span>         steal_suitable_fallback(zone, page, start_migratetype, can_steal);</span><br><span class="line"><span class="number">2444</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-慢分配-alloc-pages-slowpath"><a href="#4-4-3-慢分配-alloc-pages-slowpath" class="headerlink" title="4.4.3 慢分配 alloc_pages_slowpath"></a>4.4.3 慢分配 alloc_pages_slowpath</h4><p>在快分配失败后，系统会尝试其他各种途径来分配到内存，<code>alloc_pages_slowpath</code>的具体实现步骤如下：</p>
<ol>
<li>降低水准<code>ALLOC_WMARK_MIN</code>重新构建分配标志。如果设置了<code>__GFP_KSWAPD_RECLAIM</code>标志则唤醒<code>kswaped</code>进程进行页面回收。</li>
<li>调用<code>get_page_from_freelist</code>尝试重新分配.</li>
<li>前面的步骤没有分配到内存，并且<code>order</code>大于<code>0</code>，进行内存压缩和页的迁移，然后尝试内存分配。</li>
<li>前面的步骤没有分配到内存，如果设置了<code>__GFP_KSWAPD_RECLAIM</code>则唤醒<code>kswaped</code>进程，确保<code>kswaped</code>进程在循环中不会睡眠。</li>
<li>前面的步骤没有分配到内存，对<code>gfp_mask</code>分析看是否可以进行无水准分配。</li>
<li>前面的步骤没有分配到内存，在调整<code>zonelist</code>和<code>alloc_flags</code>之后再次尝试分配。</li>
<li>前面的步骤没有分配到内存，直接进行内存回收之后尝试内存分配。</li>
<li>若内存回收没有分配到所需内存，就直接进行内存压缩之后尝试内存分配。</li>
<li>如果没有回收到足够的内存就尝试杀死一些进程然后尝试分配内存。</li>
<li>如果仍然没有分配到内存，分配标志中设置了<code>__GFP_NOFAIL</code>就设置<code>ALLOC_HARDER</code>尝试做内存分配</li>
</ol>
<h2 id="0x05-页框释放回收"><a href="#0x05-页框释放回收" class="headerlink" title="0x05 页框释放回收"></a>0x05 页框释放回收</h2><p>释放页框的函数调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">free_pages()</span><br><span class="line">    --&gt; __free_pages()</span><br><span class="line">        --&gt; <span class="keyword">if</span> (order == <span class="number">0</span> )--&gt; free_unref_page(<span class="number">0</span>) <span class="comment">// 释放单页</span></span><br><span class="line">        |                       --&gt; free_unref_page_commit()</span><br><span class="line">        |                           --&gt; 该页的pageblock的迁移类型不是CPU高速缓存类型，则返回伙伴系统 --&gt; free_one_page()</span><br><span class="line">        |                           --&gt; 放入CPU高速缓 ，默认为热页，如果缓存中页的数量大于pcp-&gt;high，则将pcp-&gt;batch数量的页返回伙伴系统 --&gt; free_pcppages_bulk()</span><br><span class="line">        --&gt; <span class="keyword">else</span> --&gt; __free_pages_ok()</span><br><span class="line">                        --&gt; free_one_page()<span class="comment">//将页块放回伙伴系统，并且会尝试合并</span></span><br></pre></td></tr></table></figure>
<p>函数<code>free_pages()</code>用于释放内存页，传入的参数是页虚拟地址和<code>order</code>，首先将<code>page</code>虚拟地址转换成页描述符，然后调用<code>__free_pages()</code>函数进一步处理。<code>__free_pages()</code>函数首先判断该页框是否还有进程在使用，即<code>_count</code>变量是否为0。如果没有进程在使用当前页框，则根据<code>order</code>值判断是释放的单页还是页块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否还有进程在使用当前页框</span></span><br><span class="line"> <span class="keyword">if</span> (put_page_testzero(page)) &#123;</span><br><span class="line"><span class="number">4476</span>                 <span class="keyword">if</span> (order == <span class="number">0</span>)<span class="comment">//释放单页</span></span><br><span class="line"><span class="number">4477</span>                         free_unref_page(page);</span><br><span class="line"><span class="number">4478</span>                 <span class="keyword">else</span></span><br><span class="line"><span class="number">4479</span>                         __free_pages_ok(page, order);</span><br><span class="line"><span class="number">4480</span>         &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-释放单页"><a href="#5-1-释放单页" class="headerlink" title="5.1 释放单页"></a>5.1 释放单页</h3><p><code>free_unref_page_commit()</code>函数中首先会获取该页框所在<code>pageblock</code>的迁移类型，根据得到的<code>migratetype</code>来判断是否属于<code>CPU</code>高速缓存，如果不是，则调用<code>free_one_page</code>放回伙伴系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2786</span>         <span class="keyword">if</span> (migratetype &gt;= MIGRATE_PCPTYPES) &#123;</span><br><span class="line"><span class="number">2787</span>                 <span class="keyword">if</span> (unlikely(is_migrate_isolate(migratetype))) &#123;<span class="comment">//如果不是CPU高速缓存类型，则放回伙伴系统</span></span><br><span class="line"><span class="number">2788</span>                         free_one_page(zone, page, pfn, <span class="number">0</span>, migratetype);</span><br><span class="line"><span class="number">2789</span>                         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">2790</span>                 &#125;</span><br><span class="line"><span class="number">2791</span>                 migratetype = MIGRATE_MOVABLE;</span><br><span class="line"><span class="number">2792</span>         &#125;</span><br></pre></td></tr></table></figure>
<p>否则该页加入<code>CPU</code>高速缓存，默认为热页。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2793</span> <span class="comment">//放入CPU高速缓存中，默认将当前页当成热页，放入相应迁移类型的链表的表头。如果是冷页，则会添加到链表尾</span></span><br><span class="line"><span class="number">2794</span>         pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line"><span class="number">2795</span>         list_add(&amp;page-&gt;lru, &amp;pcp-&gt;lists[migratetype]);</span><br><span class="line"><span class="number">2796</span>         pcp-&gt;count++;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>CPU</code>高速缓存中的页数高于其最大值<code>pcp-&gt;high</code>，则会将<code>pcp-&gt;batch</code>数量的页放回伙伴系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2798</span>         <span class="keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high) &#123;</span><br><span class="line"><span class="number">2799</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> batch = READ_ONCE(pcp-&gt;batch);</span><br><span class="line"><span class="number">2800</span>                 free_pcppages_bulk(zone, batch, pcp);</span><br><span class="line"><span class="number">2801</span>         &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-free-pcppages-bulk"><a href="#5-1-2-free-pcppages-bulk" class="headerlink" title="5.1.2 free_pcppages_bulk()"></a>5.1.2 free_pcppages_bulk()</h4><p>当<code>CPU</code>高速缓存中的页数高于最大值时，要回收<code>pcp-&gt;batch</code>数量的页到伙伴系统。具体回收<code>CPU</code>高速缓存中的那些迁移类型列表的那些页，具体的实现逻辑在<code>free_pcppages_bulk()</code>函数，<code>pcp lists</code>中根据迁移类型不同有多个不同的链表，要释放<code>pcp-&gt;batch</code>数量的页到伙伴系统，该函数会根据迁移类型循环遍历<code>pcp lists</code>，每次取出一个非空的链表，释放<code>batch_free</code>数量的页，直到释放完了<code>pcp-&gt;batch</code>个页，具体代码逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1115</span>                 <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">1116</span>                         batch_free++;</span><br><span class="line"><span class="number">1117</span>                         <span class="keyword">if</span> (++migratetype == MIGRATE_PCPTYPES)<span class="comment">//MIGRATE_PCPTYPES == 3</span></span><br><span class="line"><span class="number">1118</span>                                 migratetype = <span class="number">0</span>;</span><br><span class="line"><span class="number">1119</span>                         <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line"><span class="number">1120</span>                 &#125; <span class="keyword">while</span> (list_empty(<span class="built_in">list</span>));</span><br></pre></td></tr></table></figure>
<p>由代码可以看出，越后面的<code>list</code>释放的页越多，一次比前一个链表多释放一个页。<br>在前面已经选出的链表，循环释放<code>batch_free</code>个页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1126</span>                 <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">1127</span>                        <span class="comment">//取list的最后一个页</span></span><br><span class="line"><span class="number">1128</span>                         page = list_last_entry(<span class="built_in">list</span>, struct page, lru);</span><br><span class="line"><span class="number">1129</span>                         <span class="comment">/* must delete to avoid corrupting pcp list */</span></span><br><span class="line"><span class="number">1130</span>                         list_del(&amp;page-&gt;lru);<span class="comment">//将该页从lru链表中删除</span></span><br><span class="line"><span class="number">1131</span>                         pcp-&gt;count--;</span><br><span class="line"><span class="number">1132</span>                        <span class="comment">/* 在释放之前进行一些检查,会调用free_pages_check()函数</span></span><br><span class="line"><span class="comment">                             * 检测page的flag，maping,_count,_mapcount来判断是否可以释放*/</span></span><br><span class="line"><span class="number">1133</span>                         <span class="keyword">if</span> (bulkfree_pcp_prepare(page))</span><br><span class="line"><span class="number">1134</span>                                 <span class="keyword">continue</span>;<span class="comment">//如果不可以，则继续遍历下一页</span></span><br><span class="line"><span class="number">1135</span>                        <span class="comment">//将取出的页添加到head为链表头的list</span></span><br><span class="line"><span class="number">1136</span>                         list_add_tail(&amp;page-&gt;lru, &amp;head);</span><br><span class="line"><span class="number">1137</span></span><br><span class="line"><span class="number">1138</span>                         <span class="comment">/*</span></span><br><span class="line"><span class="comment">1139                          * We are going to put the page back to the global</span></span><br><span class="line"><span class="comment">1140                          * pool, prefetch its buddy to speed up later access</span></span><br><span class="line"><span class="comment">1141                          * under zone-&gt;lock. It is believed the overhead of</span></span><br><span class="line"><span class="comment">1142                          * an additional test and calculating buddy_pfn here</span></span><br><span class="line"><span class="comment">1143                          * can be offset by reduced memory latency later. To</span></span><br><span class="line"><span class="comment">1144                          * avoid excessive prefetching due to large count, only</span></span><br><span class="line"><span class="comment">1145                          * prefetch buddy for the first pcp-&gt;batch nr of pages.</span></span><br><span class="line"><span class="comment">1146                          */</span></span><br><span class="line"><span class="number">1147</span>                         <span class="keyword">if</span> (prefetch_nr++ &lt; pcp-&gt;batch)</span><br><span class="line"><span class="number">1148</span>                                 prefetch_buddy(page);</span><br><span class="line"><span class="number">1149</span>                 &#125; <span class="keyword">while</span> (--count &amp;&amp; --batch_free &amp;&amp; !list_empty(<span class="built_in">list</span>));</span><br><span class="line"><span class="number">1150</span>         &#125;</span><br></pre></td></tr></table></figure>
<p>当遍历完<code>pcp lists</code>中的<code>list</code>，所有要放回到<code>buddy</code>系统的<code>count</code>个页框现在全部链接在以<code>head</code>为表头的<code>list</code>中，然后调用<code>list_for_each_entry_safe</code>宏将该<code>list</code>中的所有的页通过<code>__free_one_page()</code>函数放回到<code>buddy</code>系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1160</span>         list_for_each_entry_safe(page, tmp, &amp;head, lru) &#123;</span><br><span class="line"><span class="number">1161</span>                 <span class="keyword">int</span> mt = get_pcppage_migratetype(page);</span><br><span class="line"><span class="number">1162</span>                 <span class="comment">/* MIGRATE_ISOLATE page should not go to pcplists */</span></span><br><span class="line"><span class="number">1163</span>                 VM_BUG_ON_PAGE(is_migrate_isolate(mt), page);</span><br><span class="line"><span class="number">1164</span>                 <span class="comment">/* Pageblock could have been isolated meanwhile */</span></span><br><span class="line"><span class="number">1165</span>                 <span class="keyword">if</span> (unlikely(isolated_pageblocks))</span><br><span class="line"><span class="number">1166</span>                         mt = get_pageblock_migratetype(page);</span><br><span class="line"><span class="number">1167</span></span><br><span class="line"><span class="number">1168</span>                 __free_one_page(page, page_to_pfn(page), zone, <span class="number">0</span>, mt);</span><br><span class="line"><span class="number">1169</span>                 trace_mm_page_pcpu_drain(page, <span class="number">0</span>, mt);</span><br><span class="line"><span class="number">1170</span>         &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-释放多页"><a href="#5-1-释放多页" class="headerlink" title="5.1 释放多页"></a>5.1 释放多页</h3><p>当<code>order</code>大于0，回调用<code>__free_pages_ok()</code>函数来进行回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1266</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn = page_to_pfn(page);<span class="comment">//获取页框号</span></span><br><span class="line"><span class="number">1267</span> <span class="comment">//各种检查</span></span><br><span class="line"><span class="number">1268</span>         <span class="keyword">if</span> (!free_pages_prepare(page, order, <span class="literal">true</span>))</span><br><span class="line"><span class="number">1269</span>                 <span class="keyword">return</span>;</span><br><span class="line"><span class="number">1270</span> <span class="comment">//获取当前页框的迁移类型</span></span><br><span class="line"><span class="number">1271</span>         migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line"><span class="number">1272</span>         local_irq_save(flags);</span><br><span class="line"><span class="number">1273</span>         <span class="comment">//统计当前CPU一共释放的页框数</span></span><br><span class="line"><span class="number">1274</span>         __count_vm_events(PGFREE, <span class="number">1</span> &lt;&lt; order);</span><br><span class="line"><span class="number">1275</span>         <span class="comment">//释放页块</span></span><br><span class="line"><span class="number">1276</span>         free_one_page(page_zone(page), page, pfn, order, migratetype);</span><br><span class="line"><span class="number">1277</span>         local_irq_restore(flags);</span><br></pre></td></tr></table></figure>
<p>在进行一些必要的检查之后，调用核心函数<code>free_one_page()</code>释放<code>order</code>阶个页框到<code>buddy</code>系统。并且回收的时候还会检查相邻页块是否空闲，如果空闲，会进行合并成大块，添加到相应阶的链表中，继续往后检查，直到检查到<code>max_order-1</code>的链表为止。具体逻辑_<code>_free_one_page()</code>函数中。</p>
<h4 id="5-2-1-free-one-page"><a href="#5-2-1-free-one-page" class="headerlink" title="5.2.1 __free_one_page()"></a>5.2.1 __free_one_page()</h4><h5 id="5-2-1-1-pageblock"><a href="#5-2-1-1-pageblock" class="headerlink" title="5.2.1.1 pageblock"></a>5.2.1.1 pageblock</h5><p>在内核中，内存被分成一小块一小块的，每个小块被称为一个<code>pageblock</code>，每个<code>pageblock</code>包含<code>order</code>阶个空闲页框，并且都属于同一类型。<br>详细分析<strong>TODO</strong></p>
<h2 id="0xFF-Reference"><a href="#0xFF-Reference" class="headerlink" title="0xFF Reference"></a>0xFF Reference</h2><p><a href="https://blog.csdn.net/chenying126/article/details/78385364" target="_blank" rel="noopener">https://blog.csdn.net/chenying126/article/details/78385364</a><br><a href="http://www.ilinuxkernel.com" target="_blank" rel="noopener">http://www.ilinuxkernel.com</a><br><a href="https://www.cnblogs.com/zhaoyl/p/3695517.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyl/p/3695517.html</a><br><a href="https://www.jeanleo.com/2018/09/06/【linux内存源码分析】页面迁移/" target="_blank" rel="noopener">https://www.jeanleo.com/2018/09/06/【linux内存源码分析】页面迁移/</a><br><a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/blob/master/study/kernel/02-memory/01-description/01-memory/README.md" target="_blank" rel="noopener">https://github.com/gatieme/LDD-LinuxDeviceDrivers/blob/master/study/kernel/02-memory/01-description/01-memory/README.md</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/50776300" target="_blank" rel="noopener">https://blog.csdn.net/YuZhiHui_No1/article/details/50776300</a><br><a href="https://cloud.tencent.com/developer/article/1379737" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1379737</a><br>分配掩码：<a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel/02-memory/04-buddy/05-free_page" target="_blank" rel="noopener">https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel/02-memory/04-buddy/05-free_page</a><br><a href="https://www.cnblogs.com/tolimit/p/5287801.html" target="_blank" rel="noopener">https://www.cnblogs.com/tolimit/p/5287801.html</a><br><a href="https://www.cnblogs.com/tolimit/p/4610974.html" target="_blank" rel="noopener">https://www.cnblogs.com/tolimit/p/4610974.html</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    v1cky01dxp
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://v1ckydxp.github.io/archives/2019/11/09/2019-10-04-Linux内核页面分配/" title="Linux 内核物理页面内存分配">https://v1ckydxp.github.io/archives/2019/11/09/2019-10-04-Linux内核页面分配/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://v1ckydxp.github.io" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux-kernel-页面分配/" rel="tag"># linux-kernel 页面分配</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/09/AFL-fuzz-入门&源码分析/" rel="next" title="AFL fuzz 入门 & 源码分析">
                <i class="fa fa-chevron-left"></i> AFL fuzz 入门 & 源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/10/2019-11-10-fuzz论文总结（一）/" rel="prev" title="FUZZ 论文总结（一）">
                FUZZ 论文总结（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">v1cky01dxp</p>
	      <img class="site-author-image" itemprop="image" src="/images/head.jpeg" alt="v1cky01dxp">
	      <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/v1ckydxp" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:sunshinedxp@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/helica/" title="helica" target="_blank">helica</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ama2in9.top/" title="ama2in9" target="_blank">ama2in9</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-前言"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-UMA和NUMA模型"><span class="nav-number">2.</span> <span class="nav-text">0x01 UMA和NUMA模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-UMA模型"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 UMA模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-NUMA模型"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 NUMA模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-Linux物理内存组织形式"><span class="nav-number">3.</span> <span class="nav-text">0x02 Linux物理内存组织形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-内存组织形式"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 内存组织形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-相关数据结构"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-内存节点描述符-struct-pglist-data"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 内存节点描述符 - struct pglist_data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-管理区描述符-struct-zone"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 管理区描述符 - struct zone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-页框描述符-struct-page"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 页框描述符 - struct page</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-每CPU页框高速缓存-struct-per-cpu-pages"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.2.4 每CPU页框高速缓存 - struct per_cpu_pages</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-页面分配与回收API"><span class="nav-number">4.</span> <span class="nav-text">0x03 页面分配与回收API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-NUMA架构alloc-pages函数实现"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 NUMA架构alloc_pages函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-UMA架构alloc-pages函数实现"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 UMA架构alloc_pages函数实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-alloc-pages-nodemask-函数源码分析"><span class="nav-number">5.</span> <span class="nav-text">0x04 __alloc_pages_nodemask()函数源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-water-mark–水准"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 water_mark–水准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-gfp-mask"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 gfp_mask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-内存域修饰符与内存分配器扫描内存域顺序的关系"><span class="nav-number">5.2.1.</span> <span class="nav-text">4.2.1 内存域修饰符与内存分配器扫描内存域顺序的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-内存分配标志"><span class="nav-number">5.2.2.</span> <span class="nav-text">4.2.2 内存分配标志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-alloc-pages-nodemask源码分析"><span class="nav-number">5.3.</span> <span class="nav-text">4.4  __alloc_pages_nodemask源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-前期check-amp-struct-alloc-context结构体变量ac初始化"><span class="nav-number">5.3.1.</span> <span class="nav-text">4.4.1 前期check &amp; struct alloc_context结构体变量ac初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-快分配-–-get-page-from-freelist"><span class="nav-number">5.3.2.</span> <span class="nav-text">4.4.2 快分配 –  get_page_from_freelist</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-1-rmqueue"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">4.4.2.1 rmqueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-2-rmqueue-pcplist"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">4.4.2.2 rmqueue_pcplist()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-3-rmqueue-smallest"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">4.4.2.3 __rmqueue_smallest()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-4-rmqueue"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">4.4.2.4 __rmqueue()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-慢分配-alloc-pages-slowpath"><span class="nav-number">5.3.3.</span> <span class="nav-text">4.4.3 慢分配 alloc_pages_slowpath</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-页框释放回收"><span class="nav-number">6.</span> <span class="nav-text">0x05 页框释放回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-释放单页"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 释放单页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-free-pcppages-bulk"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.2 free_pcppages_bulk()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-释放多页"><span class="nav-number">6.2.</span> <span class="nav-text">5.1 释放多页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-free-one-page"><span class="nav-number">6.2.1.</span> <span class="nav-text">5.2.1 __free_one_page()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-1-pageblock"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">5.2.1.1 pageblock</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xFF-Reference"><span class="nav-number">7.</span> <span class="nav-text">0xFF Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">v1cky01dxp</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">78.5k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
